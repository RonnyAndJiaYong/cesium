<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Use correct character set. -->
    <meta charset="utf-8" />
    <!-- Tell IE to use the latest, best version. -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <title>Hello World!</title>
    <script src="../../Build/CesiumUnminified/Cesium.js"></script>
    <script src="./util.js"></script>
    <script src="./offSceneCanvas.js"></script>
    <style>
      @import url(../../Build/CesiumUnminified/Widgets/widgets.css);
      html,
      body,
      #cesiumContainer {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      .video1 {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 99999;
      }
      .right {
        width: 50%;
        height: 100%;
        position: absolute;
        right: 0px;
        z-index: 1000;
        top: 0;
        border: 1px solid red;
      }
    </style>
  </head>
  <body onload="load()">
    <div id="cesiumContainer"></div>
    <div class="right">
      <canvas id="webgl" :width="960" :height="937"></canvas>
    </div>
    <div class="video1">
      <video
        width="320"
        height="240"
        controls
        autoplay
        id="trailer"
        crossorigin=""
      >
        <source
          src="http://172.16.115.83:3839/api/video/6.mp4"
          type="video/mp4"
        />
        您的浏览器不支持Video标签。
      </video>
    </div>
    <script>
      const viewer = new Cesium.Viewer("cesiumContainer");
      const myCamera = new Cesium.Camera(viewer.scene); // 自定义相机

      let isCameraReady = false;
      function load() {
        initWebgl();
        initPlane();
      }

      function initOffScene() {
        const { scene } = viewer;
        const viewport = new Cesium.BoundingRectangle(
          0,
          0,
          scene.context.drawingBufferWidth,
          scene.context.drawingBufferHeight
        );
        scene._offscreenView = new Cesium.View(scene, myCamera, viewport);
      }
      function initPlane() {
        // 定义矩形宽度和高度
        const width = 256.0;
        const height = 144.0;
        const initPosition = new Cesium.Cartesian3(
          -2331429.804452902,
          5383058.464155658,
          2495349.6435902063
        );
        // 创建矩形实体
        const rectangle = getRecBypoint(initPosition, width, height);
        let videoPolygon = viewer.entities.add({
          name: "videoPolygon",
          rectangle: {
            coordinates: rectangle,
            material: document.getElementById("trailer"),
            classificationType: Cesium.ClassificationType.TERRAIN,
          },
        });
        viewer.flyTo(videoPolygon);

        // 新增一个相机
        const initPosition2 = Cesium.Cartesian3.fromDegrees(
          Number(113.41768),
          Number(23.18258),
          Number(77.326)
        );
        myCamera.position = initPosition2;
        const heading = Cesium.Math.toRadians(50.0);
        const pitch = Cesium.Math.toRadians(-90.0);
        const range = 5000.0;
        myCamera.lookAt(
          initPosition,
          new Cesium.HeadingPitchRange(heading, pitch, range)
        );
        // let myprimitive = viewer.scene.primitives.add(new Cesium.DebugCameraPrimitive({
        //    camera : camera,
        //    color : Cesium.Color.YELLOW
        //  }));
        //  camera.position = initPosition2;
        initOffScene();
        isCameraReady = true;
      }

      // 贴图
      let colorTexture;
      // 深度图
      let depthStencilTexture;
      // 颜色贴图
      let colorFramebuffer;

      // 创建Framebuffer的方法
      function createFramebuffer(context, width, height, hdr) {
        console.log(colorTexture);
        const myColorTexture = colorTexture;
        // 如果创建过colorTexture，并且colorTexture的尺寸、HDR都没改变的话，就不需要更新了
        if (
          Cesium.defined(myColorTexture) &&
          myColorTexture.width === width &&
          myColorTexture.height === height
        ) {
          return;
        }

        // 销毁原来的Framebuffer
        destroyResource();

        // 如果没使用高光动态渲染，则像素格式为无符号整型，如果使用了高光动态渲染，则需要判断是双浮点还是单浮点
        const pixelDatatype = hdr // 如果使用高光动态渲染
          ? context.halfFloatingPointTexture // 如果是半浮点纹理
            ? Cesium.PixelDatatype.HALF_FLOAT
            : Cesium.PixelDatatype.FLOAT
          : Cesium.PixelDatatype.UNSIGNED_BYTE;

        // 创建颜色贴图
        colorTexture = new Cesium.Texture({
          context: context,
          width: width,
          height: height,
          pixelFormat: Cesium.PixelFormat.RGBA, // 输出纹理的格式
          pixelDatatype: pixelDatatype, // 输出纹理的像素格式
          sampler: new Cesium.Sampler({
            // 设置采样器
            wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE, // 超出范围被截取成0-1
            wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE, // 超出范围被截取成0-1
            minificationFilter: Cesium.TextureMinificationFilter.LINEAR, // 通过最近的四个像素点进行双线性内插
            magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR, // 通过最近的四个像素点进行双线性内插
          }),
        });

        // 创建深度测试的纹理
        depthStencilTexture = new Cesium.Texture({
          context: context,
          width: width,
          height: height,
          pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL, // 输出纹理为的格式
          pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8, // 输出纹理的像素数据格式
        });

        // 创建Framebuffer
        colorFramebuffer = new Cesium.Framebuffer({
          context: context,
          colorTextures: [colorTexture],
          depthStencilTexture: depthStencilTexture,
          destroyAttachments: false,
        });
        return colorFramebuffer;
      }

      function destroyResource() {
        colorTexture?.destroy();
        depthStencilTexture?.destroy();
        colorFramebuffer?.destroy();
        colorTexture = undefined;
        depthStencilTexture = undefined;
        colorFramebuffer = undefined;
      }

      function debugOutputReflectionTexture(context, width, height) {
        const pixels = context.readPixels({
          framebuffer: colorFramebuffer,
        });
        const imageData = new ImageData(
          new Uint8ClampedArray(pixels),
          width,
          height
        );
        return imageData;
      }

      /* 监听渲染 */
      function render(scene, passStateFramebuffer, camera) {
        // 获取场景中的帧状态
        const frameState = scene._frameState;
        // 获取上下文
        const { context } = scene;
        // 获取webgl中的全局变量
        const us = context.uniformState;
        const view = scene._offscreenView;
        view.camera = camera;
        // scene._view = view;

        // 先更新一次状态
        scene.updateFrameState();
        // 设置正在渲染（否则会无法渲染）
        frameState.passes.render = true;
        // 设置是否使用后处理
        frameState.passes.postProcess = scene.postProcessStages.hasSelected;
        // 设置3dtiles的渲染状态
        frameState.tilesetPassState = new Cesium.Cesium3DTilePassState({
          pass: Cesium.Cesium3DTilePass.RENDER,
        });

        // 更新场景fog状态
        scene.fog.update(frameState);

        // 更新全局变量状态
        us.update(frameState);

        // 加入阴影（不加下面的没有阴影）
        const { shadowMap } = scene;
        if (Cesium.defined(shadowMap) && shadowMap.enabled) {
          if (!Cesium.defined(scene.light) || scene.light) {
            // Negate the sun direction so that it is from the Sun, not to the Sun
            Cesium.Cartesian3.negate(
              us.sunDirectionWC,
              scene._shadowMapCamera.direction
            );
          } else {
            Cesium.Cartesian3.clone(
              scene.light.direction,
              scene._shadowMapCamera.direction
            );
          }
          frameState.shadowMaps.push(shadowMap);
        }

        // 渲染指令列表 = 0；
        scene._computeCommandList.length = 0;
        // 透明膜命令列表 = 0；
        scene._overlayCommandList.length = 0;

        // 获取渲染状态
        const { passState } = view;
        passState.framebuffer = passStateFramebuffer;
        // passState.blendingEnabled = undefined;
        // 裁剪测试
        passState.scissorTest = undefined;
        // 设置视野范围
        const { viewport } = view;
        viewport.x = 0;
        viewport.y = 0;
        viewport.width = context.drawingBufferWidth;
        viewport.height = context.drawingBufferHeight;
        passState.viewport = Cesium.BoundingRectangle.clone(
          viewport,
          passState.viewport
        );

        // 设置起始帧
        if (Cesium.defined(scene.globe)) {
          scene.globe.beginFrame(frameState);
        }

        // 更新场景环境
        scene.updateEnvironment();
        // 更新和执行命令
        scene.updateAndExecuteCommands(passState, scene.backgroundColor);
        // 解析帧缓冲区
        scene.resolveFramebuffers(passState);

        if (Cesium.defined(scene.globe)) {
          scene.globe.endFrame(frameState);

          if (!scene.globe.tilesLoaded) {
            scene._renderRequested = true;
          }
        }

        context.endFrame();
      }

      viewer.scene.postRender.addEventListener(postRenderCallback);
      // 在每一帧渲染结束后触发的事件
      function postRenderCallback(scene, time) {
        // 在这里编写你想要执行的代码
        if (!isCameraReady) {
          return;
        }
        const { context } = viewer.scene;
        const width = context.drawingBufferWidth;
        const height = context.drawingBufferHeight;
        const hdr = scene.highDynamicRange;
        colorFramebuffer = createFramebuffer(context, width, height, hdr);
        render(scene, colorFramebuffer, myCamera);
        // 输出反射纹理
        const reflectionImageData = debugOutputReflectionTexture(
          context,
          width,
          height
        );
        updateWebGLTexture(reflectionImageData);
      }
    </script>
  </body>
</html>
